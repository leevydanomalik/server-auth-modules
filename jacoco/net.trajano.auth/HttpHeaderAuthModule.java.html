<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HttpHeaderAuthModule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Server Auth Modules</a> &gt; <a href="index.source.html" class="el_package">net.trajano.auth</a> &gt; <span class="el_source">HttpHeaderAuthModule.java</span></div><h1>HttpHeaderAuthModule.java</h1><pre class="source lang-java linenums">package net.trajano.auth;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.text.MessageFormat;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.security.auth.Subject;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import javax.security.auth.message.AuthException;
import javax.security.auth.message.AuthStatus;
import javax.security.auth.message.MessageInfo;
import javax.security.auth.message.MessagePolicy;
import javax.security.auth.message.callback.CallerPrincipalCallback;
import javax.security.auth.message.callback.GroupPrincipalCallback;
import javax.security.auth.message.module.ServerAuthModule;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * HTTP header server auth module. This can be used with SiteMinder type data.
 *
 * @author Archimedes Trajano
 *
 */
<span class="fc" id="L34">public class HttpHeaderAuthModule implements ServerAuthModule {</span>

    /**
     * Group Header option key.
     */
    private static final String GROUP_HEADER_KEY = &quot;group_header&quot;;

    /**
     * Logger.
     */
    private static final Logger LOG;

    /**
     * Messages resource path.
     */
    private static final String MESSAGES = &quot;META-INF/Messages&quot;;

    /**
     * Resource bundle.
     */
    private static final ResourceBundle R;

    /**
     * User Name Header option key.
     */
    public static final String USERNAME_HEADER_KEY = &quot;username_header&quot;;

    static {
<span class="fc" id="L62">        LOG = Logger.getLogger(&quot;net.trajano.auth.httpheadersam&quot;, MESSAGES);</span>
<span class="fc" id="L63">        R = ResourceBundle.getBundle(MESSAGES);</span>
<span class="fc" id="L64">    }</span>

    /**
     * Group header option.
     */
    private String groupHeader;

    /**
     * Callback handler that is passed in initialize by the container. This
     * processes the callbacks which are objects that populate the &quot;subject&quot;.
     */
    private CallbackHandler handler;

    /**
     * Mandatory flag.
     */
    private boolean mandatory;

    /**
     * User name header option.
     */
    private String userNameHeader;

    /**
     * Does nothing.
     *
     * @param messageInfo
     *            message info
     * @param subject
     *            subject
     */
    @Override
    public void cleanSubject(final MessageInfo messageInfo,
            final Subject subject) throws AuthException {
        // Does nothing.
<span class="nc" id="L99">    }</span>

    /**
     * &lt;p&gt;
     * Supported message types. For our case we only need to deal with HTTP
     * servlet request and responses. On Java EE 7 this will handle WebSockets
     * as well.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This creates a new array for security at the expense of performance.
     * &lt;/p&gt;
     *
     * @return {@link HttpServletRequest} and {@link HttpServletResponse}
     *         classes.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    @Override
    public Class[] getSupportedMessageTypes() {
<span class="nc" id="L117">        return new Class&lt;?&gt;[] { HttpServletRequest.class,</span>
                HttpServletResponse.class };
    }

    /**
     * Builds a list of groups from the request. If not defined, then &quot;users&quot; is
     * returned.
     *
     * @param req
     *            servlet request.
     * @return array of groups.
     */
    private String[] groups(final HttpServletRequest req) {
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (groupHeader == null) {</span>
<span class="nc" id="L131">            return new String[] { &quot;users&quot; };</span>
        }
<span class="nc" id="L133">        final List&lt;String&gt; groupList = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L134">        final Enumeration&lt;String&gt; groupHeaders = req.getHeaders(groupHeader);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        while (groupHeaders.hasMoreElements()) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            for (final String groupName : groupHeaders.nextElement().split(&quot;,&quot;)) {</span>
<span class="nc" id="L137">                groupList.add(groupName.trim());</span>
            }
        }
<span class="nc" id="L140">        return groupList.toArray(new String[0]);</span>
    }

    /**
     * {@inheritDoc}
     *
     * @param requestPolicy
     *            request policy, ignored
     * @param responsePolicy
     *            response policy, ignored
     * @param h
     *            callback handler
     * @param options
     *            options
     */
    @Override
    public void initialize(final MessagePolicy requestPolicy,
            final MessagePolicy responsePolicy, final CallbackHandler h,
            @SuppressWarnings(&quot;rawtypes&quot;) final Map options)
                    throws AuthException {
<span class="fc" id="L160">        handler = h;</span>
<span class="fc" id="L161">        mandatory = requestPolicy.isMandatory();</span>
<span class="fc" id="L162">        userNameHeader = (String) options.get(USERNAME_HEADER_KEY);</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (userNameHeader == null) {</span>
<span class="nc" id="L164">            LOG.log(Level.SEVERE, &quot;missingOption&quot;, USERNAME_HEADER_KEY);</span>
<span class="nc" id="L165">            throw new AuthException(MessageFormat.format(</span>
                    R.getString(&quot;missingOption&quot;), USERNAME_HEADER_KEY));
        }
<span class="fc" id="L168">        groupHeader = (String) options.get(GROUP_HEADER_KEY);</span>
<span class="fc" id="L169">    }</span>

    /**
     * Return {@link AuthStatus#SEND_SUCCESS}.
     *
     * @param messageInfo
     *            contains the request and response messages. At this point the
     *            response message is already committed so nothing can be
     *            changed.
     * @param subject
     *            subject.
     * @return {@link AuthStatus#SEND_SUCCESS}
     */
    @Override
    public AuthStatus secureResponse(final MessageInfo messageInfo,
            final Subject subject) throws AuthException {
<span class="nc" id="L185">        return AuthStatus.SEND_SUCCESS;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AuthStatus validateRequest(final MessageInfo messageInfo,
            final Subject client, final Subject serviceSubject)
                    throws AuthException {
<span class="fc" id="L195">        final HttpServletRequest req = (HttpServletRequest) messageInfo</span>
                .getRequestMessage();
<span class="fc" id="L197">        final HttpServletResponse resp = (HttpServletResponse) messageInfo</span>
                .getResponseMessage();
        try {
<span class="fc bfc" id="L200" title="All 4 branches covered.">            if (!mandatory &amp;&amp; !req.isSecure()) {</span>
<span class="fc" id="L201">                return AuthStatus.SUCCESS;</span>
            }
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (!req.isSecure()) {</span>
<span class="fc" id="L204">                resp.sendError(HttpURLConnection.HTTP_FORBIDDEN,</span>
                        R.getString(&quot;SSLReq&quot;));
<span class="fc" id="L206">                return AuthStatus.SEND_FAILURE;</span>
            }
<span class="fc" id="L208">            final String userName = req.getHeader(userNameHeader);</span>
<span class="pc bpc" id="L209" title="2 of 4 branches missed.">            if (userName == null &amp;&amp; mandatory) {</span>
<span class="nc" id="L210">                return AuthStatus.FAILURE;</span>
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">            } else if (userName == null &amp;&amp; !mandatory) {</span>
<span class="fc" id="L212">                return AuthStatus.SUCCESS;</span>
            }

<span class="nc" id="L215">            handler.handle(new Callback[] {</span>
                    new CallerPrincipalCallback(client, userName),
                    new GroupPrincipalCallback(client, groups(req)) });
<span class="nc" id="L218">            return AuthStatus.SUCCESS;</span>
<span class="nc" id="L219">        } catch (final IOException | UnsupportedCallbackException e) {</span>
<span class="nc" id="L220">            LOG.throwing(this.getClass().getName(), &quot;validateRequest&quot;, e);</span>
<span class="nc" id="L221">            throw new AuthException(e.getMessage());</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>